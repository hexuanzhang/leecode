### 思路

1. 获取待排序的数组 A 的最大值（Max）及最小值(Min)
2. 新建长度为 Max - Min + 1 的数组 B，用于记录每个元素出现的次数
3. 遍历数组 A，统计每个元素出现的次数
4. 将数组 B 中每个值与前一项相加，这样 B[A[i]] 就表示数组 A 中小于等于 A[i] 的元素个数
5. 反向填充数组 C：将数组元素 A[i] 放在数组 C 的第 B[A[i]] 个位置（索引位置：B[A[i]] - 1），每放一次，B[A[i]] 减一
6. 返回已排序数组 C

### 复杂度

按照上面的思路，需要遍历两次数组 A 以及遍历一次数组 B，那么所需的时间复杂度为 `2n + k` (k 为遍历数组 B 的时间复杂度)，空间复杂度为 `n+k` 。

|          | 最优时间复杂度 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 是否稳定排序 | 备注 |
| -------- | :------------: | :------------: | :------------: | :--------: | :----------: | ---- |
| 计数排序 |      n+k       |      n+k       |      n+k       |    n+k     |      是      |      |

### 其他

- 计数排序只能用在**数据范围不大的场景**中，数据范围越大，数组长度就越长，所需的空间越大
- 考虑到数组索引的原因，计数排序仅适用于**非负整数**的排序；当然也可以将负数或小数通过放大转换为非负整数

### 参考

- [Wikipedia](https://zh.wikipedia.org/wiki/计数排序)
- [Youtube](https://www.youtube.com/watch?v=OKd534EWcdk&index=61&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)
